<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Visual Display</title>
        <style>
            @font-face {
                font-family: "OracleMono";
                src: url("/public/fonts/Neubahn.ttf") format("truetype");
                font-display: swap;
            }

            * {
                color: #00ff08;
                box-sizing: border-box;
            }

            html,
            body {
                margin: 0;
                padding: 0;
                height: 100%;
                background: #000;
            }

            /* Center canvas, no scrolling; canvas will be sized to fit window */
            body {
                font-family:
                    OracleMono, ui-monospace, SFMono-Regular, Menlo, Monaco,
                    "Courier New", monospace;
                display: flex;
                align-items: center;
                justify-content: center;
                overflow: hidden;
                position: relative;
            }

            /* ðŸ”„ rotated wrapper for video + canvas */
            .rotator {
                position: relative;
                width: 100vh;
                height: 100vw;
                transform: rotate(-90deg);
                transform-origin: center center;
                overflow: hidden;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* Background video DOM node (used only as texture for p5) */
            .bg-video {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                min-width: 100%;
                min-height: 100%;
                width: auto;
                height: auto;
                object-fit: cover;
                z-index: -1;
                filter: grayscale(1) contrast(1.1) brightness(0.7);

                /* hide DOM video to avoid double background */
                opacity: 0;
                pointer-events: none;
            }

            /* Canvas uses its own p5 size; just ensure it never exceeds wrapper */
            canvas {
                display: block;
                max-width: 100%;
                max-height: 100%;
                width: auto;
                height: auto;
            }
        </style>

        <!-- preload font -->
        <link
            rel="preload"
            href="/fonts/Neubahn.ttf"
            as="font"
            type="font/ttf"
            crossorigin
        />

        <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    </head>

    <body>
        <!-- ðŸ”„ wrap visuals in rotated container -->
        <div class="rotator" id="rotator">
            <!-- ðŸ”¥ Background video source -->
            <video
                id="bg-video"
                class="bg-video"
                autoplay
                muted
                loop
                playsinline
            >
                <source src="/videos/neko.mp4" type="video/mp4" />
            </video>
            <!-- p5 canvas will be injected here via cnv.parent('rotator') -->
        </div>

        <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

        <script>
            // --- socket setup ---
            const params = new URLSearchParams(location.search);
            const wsURL = params.get("ws") || location.origin;
            const ioClient = io(wsURL, {
                transports: ["websocket", "polling"],
            });

            const MANUAL_FORTUNES = [
                "You work too hard. For nothing.",
                "You glow because stress kill you.",
                "Love yourself, no one want that job.",
                "Let go, lose all. Namaste.",
                "Smile. People smell your fear.",
                "You grow? Only your anxiety.",
                "Think positive. Be delulu.",
                "Keep going. Worse coming.",
                "Dream big. Rent bigger.",
                "You special? Same like everybody.",
                "Work harder. Approval not free.",
                "You â€œgrowâ€ but only eyebag big.",
                "Stay hopeful. Delulu is character.",
                "Stay positive. Ignorance burn less calorie.",
                "You want progress, desk become coffin.",
                "You chase money, job give experience only.",
                "You want rich, industry give â€œpassion.â€",
                "You want simple life, hahaha",
                "Work hard, boss forget your name.",
                "Work harder, die faster.",
                "Want happy, pay first.",
                "Want peace, get panic.",
                "Life give you fufufafa.",
                "Destiny reply â€œfufufafa only.â€",
                "Donâ€™t Worry, Really, lol.",
                "Want money. Get stress.",
                "Stop pressing button. I scared.",
                "Iâ€™m tired. You also tired.",
                "Just enjoy life, why ask? Life not enjoy you.",
                "Nope. Nope. Nope. Still nope.",
                "Why press again? Expect magic?",
                "You press button like rent free.",
                "Button cry. Please stop.",
                "You press button, problem multiply.",
                "Calm down. Button not your therapist.",
                "Stop pressing. You Drain our WIFI.",
                "Your finger strong, your life not.",
                "You press button, I lose hope.",
                "Stop pressing. Touch grass instead.",
                "Button tired. You tired. Everyone tired.",
                "Press again and I scream.",
                "Press less. Breathe more.",
                "One press good. Two press bad.",
                "No More Sir, Tired.",
                "Hidupmu kabur, nasib tidur.",
                "Rejeki telat, masalah dulu.",
                "Harapan tinggi, hasil kentang.",
                "Jalan hidupmu muter-muter.",
                "Mau sukses? berdoa aja",
                "Mimpi besar, dompet kecil.",
                "Ambisi gede, nggak realistis.",
                "Zonk mulu ya, haha.",
                "Nasibmu buffering selamanya.",
                "Harapan ON, hasil OFF.",
                "Kerja lu rajin, hidup bercanda.",
                "Hiduplu banyak gaya, dompet nyerah.",
                "Buang waktu aja disini. Kerja.",
                "Mukamu lelah, tidur aja nanti.",
                "Mimpimu terlalu tinggi.",
                "Mau simple, gayamu ribet.",
                "Nasibmu mode â€œrandom.â€",
                "Harapan banyak, hasil dikit.",
                "Mau jelas, dunia blur.",
            ];

            const MANUAL_PROB = 0.4;
            let oracleFont, bgVideoEl;
            let mode = "idle";
            let finalText = "";
            let baseTime = 0;
            let typingIdx = 0;
            let typedText = "";
            let lastTypeStep = 0;
            let TYPE_DELAY = 26;
            const FG = [34, 255, 0];
            const BG = [0, 0, 0];
            const PAD = 50;
            const pool = [
                "optimizing",
                "buffering",
                "indexing",
                "summoning",
                "distilling",
                "hydrating",
                "coalescing",
                "compiling",
                "rerendering",
                "manifesting",
                "vibesyncing",
                "reframing",
            ];
            let loadTarget = "",
                loadShown = "";
            let lastSwap = 0,
                lastType = 0;
            const swapDelay = 360,
                typeDelay = 16;
            const scaleParam = parseFloat(params.get("scale"));
            const SIZE_SCALE = isNaN(scaleParam) ? 0.25 : scaleParam;
            const lhParam = parseFloat(params.get("lh"));
            const LINE_HEIGHT_MULT = isNaN(lhParam) ? 0.8 : lhParam;

            // ====== OPTIMIZED GRAPHICS BUFFERS ======
            let screenG; // Dynamic content (video + text)
            let overlayG; // Static scanlines + vignette
            let bezelG; // Static glowing bezel (Pre-rendered!)
            let maskG; // Static corner mask (Pre-rendered!)
            let noiseG; // Static noise texture

            let flicker = 0,
                jitterX = 0,
                chromaShift = 0;
            let cursorOn = true,
                lastCursor = 0;
            let cornerR = 32,
                bezelGlow = 42;
            let textNoiseLayer;
            let trans = {
                active: false,
                from: "idle",
                to: "idle",
                t: 1,
                dur: 420,
            };

            function startTransition(nextMode) {
                if (mode === nextMode) return;
                trans.active = true;
                trans.from = mode;
                trans.to = nextMode;
                trans.t = 0;
            }

            function transitionStep(dt) {
                if (!trans.active) return;
                trans.t += dt / trans.dur;
                if (trans.t >= 1) {
                    trans.active = false;
                    mode = trans.to;
                }
            }

            let idleTimer = null;
            const IDLE_TIMEOUT_MS = 15 * 1000;
            function resetIdleTimer() {
                if (idleTimer) clearTimeout(idleTimer);
                idleTimer = setTimeout(() => {
                    startTransition("idle");
                }, IDLE_TIMEOUT_MS);
            }

            function pick(arr) {
                return arr[Math.floor(Math.random() * arr.length)];
            }
            function clamp(v, a, b) {
                return Math.max(a, Math.min(b, v));
            }
            function scramble(word) {
                const noise =
                    "!@#$%^&*()_+-=[]{};:,.?/\\|~ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                let out = "";
                for (let i = 0; i < word.length; i++) {
                    out +=
                        Math.random() < 0.45
                            ? word[i]
                            : noise[Math.floor(Math.random() * noise.length)];
                }
                return out;
            }

            function primeLoading() {
                loadTarget = scramble(pick(pool));
                loadShown = "";
                lastSwap = millis();
                lastType = millis();
            }

            const TARGET_RATIO = 9 / 16;
            function computeCanvasSize() {
                const w = window.innerHeight;
                const h = window.innerWidth;
                const windowRatio = w / h;
                let canvasW, canvasH;
                if (windowRatio > TARGET_RATIO) {
                    canvasH = h;
                    canvasW = h * TARGET_RATIO;
                } else {
                    canvasW = w;
                    canvasH = w / TARGET_RATIO;
                }
                return { w: Math.floor(canvasW), h: Math.floor(canvasH) };
            }

            function preload() {
                oracleFont = loadFont("/fonts/Neubahn.ttf");
            }

            function setup() {
                const { w, h } = computeCanvasSize();
                const cnv = createCanvas(w, h);
                cnv.parent("rotator");
                pixelDensity(1);
                textFont(oracleFont);
                textAlign(LEFT, TOP);
                noStroke();
                colorMode(RGB, 255, 255, 255, 255);

                bgVideoEl = document.getElementById("bg-video");
                if (bgVideoEl && bgVideoEl.play) {
                    bgVideoEl.play().catch(() => {});
                }

                makeBuffers();
                resetIdleTimer();
            }

            function windowResized() {
                const { w, h } = computeCanvasSize();
                resizeCanvas(w, h);
                makeBuffers();
            }

            function makeBuffers() {
                cornerR = Math.floor(Math.min(width, height) * 0.06);

                // 1. Dynamic Content Buffer
                screenG = createGraphics(width, height);
                screenG.pixelDensity(1);
                screenG.textFont(oracleFont);
                screenG.textAlign(LEFT, TOP);
                screenG.noStroke();

                // 2. Static Overlay (Scanlines + Vignette)
                overlayG = createGraphics(width, height);
                overlayG.pixelDensity(1);
                overlayG.clear();
                overlayG.noStroke();
                // Scanlines
                for (let y = 0; y < height; y += 2) {
                    const a = 20 + 4 * Math.sin(y * 0.02);
                    overlayG.fill(FG[0], FG[1], FG[2], a);
                    overlayG.rect(0, y, width, 1);
                }
                // Vignette
                overlayG.noFill();
                const steps = 20;
                for (let i = 0; i < steps; i++) {
                    const t = i / (steps - 1);
                    const a = map(t, 0, 1, 0, 45);
                    overlayG.stroke(0, 0, 0, a);
                    overlayG.strokeWeight(2);
                    const padX = width * t * 0.055;
                    const padY = height * t * 0.055;
                    overlayG.rect(
                        padX,
                        padY,
                        width - padX * 2,
                        height - padY * 2,
                        cornerR,
                    );
                }

                // 3. Static Bezel (PRE-RENDERED GLOW) - Huge performance win
                bezelG = createGraphics(width, height);
                bezelG.pixelDensity(1);
                bezelG.clear();
                bezelG.shadowBlur = bezelGlow;
                bezelG.shadowColor = "rgba(34,255,0,0.65)";
                bezelG.lineWidth = 3;
                bezelG.strokeStyle = "rgba(34,255,0,0.85)";
                bezelG.noFill();
                pathRoundedRect(
                    bezelG.drawingContext,
                    1.5,
                    1.5,
                    width - 3,
                    height - 3,
                    (HP_cornerR = cornerR),
                );
                bezelG.drawingContext.stroke();

                // 4. Static Corner Mask (Replaces clip()) - Huge performance win
                maskG = createGraphics(width, height);
                maskG.pixelDensity(1);
                maskG.background(0); // Fill black
                maskG.erase(); // Cut out the center
                maskG.noStroke();
                maskG.fill(255);
                // Draw rounded rect to erase center, leaving black corners
                pathRoundedRect(
                    maskG.drawingContext,
                    0,
                    0,
                    width,
                    height,
                    cornerR,
                );
                maskG.drawingContext.fill();
                maskG.noErase();

                // 5. Static Noise (Generated ONCE) - Removes CPU spike
                noiseG = createGraphics(width, height);
                noiseG.pixelDensity(1);
                noiseG.loadPixels();
                for (let i = 0; i < noiseG.pixels.length; i += 4) {
                    const v = Math.random() < 0.05 ? Math.random() * 255 : 0;
                    noiseG.pixels[i + 0] = v;
                    noiseG.pixels[i + 1] = v;
                    noiseG.pixels[i + 2] = v;
                    noiseG.pixels[i + 3] = v > 0 ? 40 : 0;
                }
                noiseG.updatePixels();

                textNoiseLayer = createGraphics(width, height);
                textNoiseLayer.pixelDensity(1);
                textNoiseLayer.textFont(oracleFont);
            }

            ioClient.on("visual:state", (payload) => {
                if (!payload || !payload.cmd) return;
                resetIdleTimer();
                if (payload.cmd === "loading") {
                    primeLoading();
                    startTransition("loading");
                    return;
                }
                if (payload.cmd === "show") {
                    let chosen = (payload.text || "").trim();
                    if (!chosen || Math.random() < MANUAL_PROB)
                        chosen = pick(MANUAL_FORTUNES);
                    finalText = String(chosen).trim().toUpperCase();
                    typingIdx = 0;
                    typedText = "";
                    lastTypeStep = millis();
                    startTransition("show");
                    return;
                }
            });

            function draw() {
                background(BG[0], BG[1], BG[2]);
                const dt = typeof deltaTime !== "undefined" ? deltaTime : 16;
                baseTime += dt * 0.001;

                const activePhase = trans.active ? trans.to : mode;
                const flickerAmp = activePhase === "show" ? 0.22 : 0.14;
                const flickerBase = activePhase === "show" ? 0.98 : 1.02;
                flicker =
                    flickerBase +
                    (noise(frameCount * 0.012) - 0.5) * flickerAmp;
                jitterX = (noise(frameCount * 0.07) - 0.5) * 5.0;
                chromaShift = (noise(frameCount * 0.03) - 0.5) * 5.0;

                if (millis() - lastCursor > 500) {
                    cursorOn = !cursorOn;
                    lastCursor = millis();
                }
                transitionStep(dt);

                // --- Draw Content ---
                screenG.clear();

                // Video
                if (bgVideoEl && bgVideoEl.readyState >= 2) {
                    const vw = bgVideoEl.videoWidth || 1,
                        vh = bgVideoEl.videoHeight || 1;
                    screenG.drawingContext.drawImage(
                        bgVideoEl,
                        0,
                        0,
                        vw,
                        vh,
                        0,
                        0,
                        width,
                        height,
                    );
                } else {
                    screenG.background(BG[0], BG[1], BG[2]);
                }

                screenG.push();
                screenG.translate(jitterX, 0);
                if (trans.active) {
                    const t = clamp(trans.t, 0, 1);
                    renderPhase(screenG, trans.from, (1 - t) * (1 - t));
                    renderPhase(screenG, trans.to, t * t);
                } else {
                    renderPhase(screenG, mode, 1);
                }
                screenG.pop();

                // NOTE: Removed "sliceGlitch" to prevent pipeline stalls (g.get())

                // --- Fast Compositing ---
                // 1. Draw main content
                image(screenG, 0, 0);

                // 2. Draw Vignette & Scanlines (Pre-rendered)
                drawingContext.globalAlpha = flicker;
                image(overlayG, 0, 0);
                drawingContext.globalAlpha = 1;

                // 3. Draw Noise (Pre-rendered)
                drawingContext.globalAlpha = 0.22;
                image(noiseG, 0, 0);
                drawingContext.globalAlpha = 1;

                // 4. Apply "Rounding" using Mask (instead of clip())
                image(maskG, 0, 0);

                // 5. Draw Bezel (Pre-rendered glow)
                image(bezelG, 0, 0);

                // 6. Draw Bar lines
                const barH = height * 0.08;
                noStroke();
                for (let i = 0; i < 18; i++) {
                    const t = i / 17;
                    const a = 4 + 16 * t;
                    fill(0, 0, 0, a);
                    rect(0, -barH + t * barH, width, 2);
                    rect(0, height - t * barH, width, 2);
                }
            }

            function renderPhase(g, which, alpha) {
                g.push();
                g.drawingContext.globalAlpha = alpha;
                if (which === "idle") drawIdle(g);
                else if (which === "loading") drawLoading(g);
                else if (which === "show") drawShow(g);
                g.pop();
            }

            function drawIdle(g) {
                const cursor = cursorOn ? "_" : " ";
                if (random() < 0.03) {
                    const y = PAD + 24 + random(-10, 42);
                    g.fill(FG[0], FG[1], FG[2], 24);
                    g.rect(0, y, width, random(1, 2));
                }
                g.push();
                g.textFont("Courier New");
                g.fill(...FG);
                g.textSize(18);
                g.text("SEARCHINGâ€¦", PAD, PAD);
                g.fill(FG[0], FG[1], FG[2], 100);
                g.textSize(12);
                g.text("NEKO 2000 v1.0" + cursor, PAD, PAD + 40);
                g.pop();
            }

            function drawLoading(g) {
                g.push();
                g.textFont("Courier New");
                g.fill(...FG);
                g.textSize(18);
                g.text("SEARCHINGâ€¦", PAD, PAD);
                g.pop();

                if (millis() - lastSwap > swapDelay) {
                    loadTarget = scramble(pick(pool));
                    loadShown = "";
                    lastSwap = millis();
                }
                if (millis() - lastType > typeDelay) {
                    const n = clamp(loadShown.length + 1, 0, loadTarget.length);
                    loadShown = loadTarget.slice(0, n);
                    lastType = millis();
                }
                const sweepY = (sin(baseTime * 2.0) * 0.5 + 0.5) * height;
                g.fill(FG[0], FG[1], FG[2], 20);
                g.rect(0, sweepY, width, 3);
                const fs = Math.max(18, Math.min(width, height) * 0.05);
                const s = (loadShown || "â€¦").toUpperCase();
                g.textAlign(CENTER, CENTER);
                g.textSize(fs);

                g.push();
                g.textFont("Courier New");
                const layers = 4;
                for (let i = layers; i >= 1; i--) {
                    const a = (i / layers) * 70;
                    const jx = (noise(frameCount * 0.12 + i) - 0.5) * 8;
                    const jy = (noise(frameCount * 0.19 - i) - 0.5) * 6;
                    g.fill(0, 200 + i * 6, 0, a);
                    g.text(
                        s,
                        width / 2 + chromaShift * i * 0.4 + jx,
                        height / 2 + jy,
                    );
                }
                g.fill(...FG);
                g.text(s, width / 2, height / 2);
                g.pop();
                g.textAlign(LEFT, TOP);
            }

            function drawShow(g) {
                g.textAlign(CENTER, CENTER);
                const fs = Math.max(18, Math.min(width, height) * SIZE_SCALE);
                g.textSize(fs);
                g.textLeading(fs * LINE_HEIGHT_MULT);
                const maxW = width * 0.9,
                    boxH = height * 0.9;
                const x = (width - maxW) / 2,
                    y = (height - boxH) / 2;
                const now = millis();
                if (
                    typingIdx < finalText.length &&
                    now - lastTypeStep >= TYPE_DELAY
                ) {
                    const steps = Math.max(
                        1,
                        Math.floor((now - lastTypeStep) / TYPE_DELAY),
                    );
                    typingIdx = Math.min(finalText.length, typingIdx + steps);
                    typedText = finalText.slice(0, typingIdx);
                    lastTypeStep = now;
                }
                const isTyping = typingIdx < finalText.length;
                const cursor = cursorOn ? "_" : " ";
                const toShow = (isTyping ? typedText : finalText) + cursor;

                const lines = 7;
                for (let i = lines; i >= 1; i--) {
                    const a = (i / lines) * 54;
                    g.fill(FG[0], FG[1], FG[2], a);
                    g.text(toShow, x + chromaShift * i * 0.22, y, maxW, boxH);
                }
                g.fill(...FG);
                g.text(toShow, x, y, maxW, boxH);

                // Simplified Dither (No get/put loops)
                // If you really need dither, draw a static noise texture with blend mode
                // here we skip the complex per-frame loop for speed
            }

            function pathRoundedRect(ctx, x, y, w, h, r) {
                const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
                ctx.beginPath();
                ctx.moveTo(x + rr, y);
                ctx.arcTo(x + w, y, x + w, y + h, rr);
                ctx.arcTo(x + w, y + h, x, y + h, rr);
                ctx.arcTo(x, y + h, x, y, rr);
                ctx.arcTo(x, y, x + w, y, rr);
                ctx.closePath();
            }
        </script>
    </body>
</html>
