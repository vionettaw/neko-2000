<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Control Panel</title>
    <style>
      :root { color-scheme: dark; }

      /* custom font â€“ make sure the path matches your build setup */
      @font-face {
        font-family: "OracleMono";
        src: url("/fonts/Neubahn.ttf") format("truetype");
        font-display: swap;
      }

      :root {
        --term-bg: #000000;   /* black background */
        --term-fg: #00ff08;   /* bright green text / lines / pixels */
      }

      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: var(--term-bg);
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: "OracleMono", ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace;
        color: var(--term-fg);
        overflow: hidden;
      }

      /* iPhone X-ish landscape ratio ~19.5:9 */
      #frame {
        position: relative;
        aspect-ratio: 19.5 / 9;
        width: min(100vw, calc(100vh * (19.5 / 9)));
        max-height: 100vh;

        border: 2px solid var(--term-fg);
        border-radius: 24px;
        box-sizing: border-box;
        padding: 16px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        background: var(--term-bg);
      }

      #wrap {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 24px;
        z-index: 2;
      }

      #status { display:none; }

      /* SUPER BIG text */
      .title {
        position: relative;
        max-width: 96%;
        text-align: center;
        text-transform: uppercase;
        font-family: "OracleMono", ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace;
        font-size: 10em;
        line-height: 1.0;
        color: var(--term-fg);
        text-shadow: none;
        text-wrap: balance;
        animation: idleFlicker 2.6s infinite;
      }

      @keyframes idleFlicker {
        0%, 80%, 100% { opacity: 1; }
        82% { opacity: 0.96; }
        86% { opacity: 0.99; }
      }

      .title::before,
      .title::after {
        content: attr(data-text);
        position: absolute;
        inset: 0;
        pointer-events: none;
        color: var(--term-fg);
        mix-blend-mode: screen;
        overflow: hidden;
      }

      .title::before {
        text-shadow: -2px 0 rgba(0, 255, 8, 0.7);
        transform: translate(0, 0);
        opacity: 0.12;
        animation: noiseShift1 1.8s infinite steps(2, end);
      }

      .title::after {
        text-shadow: 2px 0 rgba(0, 180, 0, 0.6);
        transform: translate(0, 0);
        opacity: 0.10;
        animation: noiseShift2 2s infinite steps(3, end);
      }

      .title.glitching::before {
        opacity: 0.45;
        animation-duration: 0.18s;
      }

      .title.glitching::after {
        opacity: 0.4;
        animation-duration: 0.22s;
      }

      @keyframes noiseShift1 {
        0%   { clip-path: inset(0 0 80% 0);  transform: translate(0, 0); }
        20%  { clip-path: inset(10% 0 60% 0); transform: translate(-1px, -1px); }
        40%  { clip-path: inset(35% 0 40% 0); transform: translate(1px, 0); }
        60%  { clip-path: inset(60% 0 20% 0); transform: translate(-1px, 1px); }
        80%  { clip-path: inset(20% 0 65% 0); transform: translate(1px, -1px); }
        100% { clip-path: inset(0 0 80% 0);  transform: translate(0, 0); }
      }

      @keyframes noiseShift2 {
        0%   { clip-path: inset(70% 0 5% 0);  transform: translate(0, 0); }
        20%  { clip-path: inset(40% 0 40% 0); transform: translate(1px, 1px); }
        40%  { clip-path: inset(15% 0 70% 0); transform: translate(-1px, 0); }
        60%  { clip-path: inset(55% 0 25% 0); transform: translate(0, -1px); }
        80%  { clip-path: inset(5% 0 75% 0);  transform: translate(1px, -1px); }
        100% { clip-path: inset(70% 0 5% 0);  transform: translate(0, 0); }
      }

      .btn {
        position: relative;
        width: min(28vh, 28vw);
        max-width: 320px;
        aspect-ratio: 1 / 1;
        border-radius: 50%;
        border: 2px solid var(--term-fg);
        background: var(--term-fg);
        cursor: pointer;
        padding: 0;
        outline: none;
        font-family: "OracleMono", ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace;
        transition:
          background 0.08s ease,
          transform 0.06s ease,
          box-shadow 0.12s ease;
        box-shadow:
          0 0 10px rgba(0,255,8,0.9),
          0 0 28px rgba(0,255,8,0.7),
          0 0 45px rgba(0,255,8,0.45);
      }

      .btn:hover {
        background: #66ff9c;
        box-shadow:
          0 0 18px rgba(0,255,8,1),
          0 0 38px rgba(0,255,8,0.9),
          0 0 65px rgba(0,255,8,0.6);
      }

      .btn:active {
        transform: translateY(1px) scale(0.97);
        background: #36ff7f;
        box-shadow:
          0 0 8px rgba(0,255,8,0.9),
          0 0 30px rgba(0,255,8,0.8);
      }

      .gridburst-canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
      }

      .vhs-overlay {
        pointer-events: none;
        position: fixed;
        inset: 0;
        mix-blend-mode: screen;
        opacity: .08;
        background:
          repeating-linear-gradient(
            to bottom,
            rgba(0,255,8,0.2) 0px,
            rgba(0,255,8,0.2) 1px,
            transparent 2px,
            transparent 3px
          );
        animation: barShift 6s linear infinite;
        z-index: 5;
      }

      @keyframes barShift {
        0%   { transform: translateY(0); }
        100% { transform: translateY(3px); }
      }

      @media (max-height: 450px) {
        #frame {
          padding: 10px;
          border-radius: 20px;
        }

        #wrap {
          gap: 14px;
        }

        .title {
          font-size: 7em;
        }

        .btn {
          width: min(24vh, 24vw);
          max-width: 260px;
        }
      }
    </style>
  </head>
  <body>
    <div class="vhs-overlay"></div>

    <div id="frame">
      <canvas id="gridburst" class="gridburst-canvas"></canvas>

      <div id="wrap">
        <div
          class="title"
          id="titleText"
          data-text="TAP WITH MIDDLE FINGER"
        >
          TAP WITH MIDDLE FINGER
        </div>

        <button
          id="trigger"
          class="btn"
          aria-label="Press to trigger glitch">
        </button>

        <div id="status"></div>
      </div>
    </div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
      const params = new URLSearchParams(location.search);
      const wsURL = params.get('ws') || location.origin;
      const ioClient = io(wsURL, { transports: ['websocket','polling'] });

      const frame = document.getElementById('frame');
      const btn   = document.getElementById('trigger');
      const cvs   = document.getElementById('gridburst');
      const ctx   = cvs.getContext('2d');
      const titleEl = document.getElementById('titleText');

      const ORIGINAL_TEXT = 'TAP WITH MIDDLE FINGER';
      const GLITCH_TEXT   = 'NEKO 2000';

      const GLITCH_DURATION   = 450;
      const NOISE_DOTS        = 220;
      const NOISE_LINES       = 40;
      const SWEEP_LINES       = 3;

      const TERM_R = 0;
      const TERM_G = 255;
      const TERM_B = 8;

      let FRAME_W = 0;
      let FRAME_H = 0;

      let raf = null;
      let glitching = false;
      let glitchStart = 0;

      function fitCanvas() {
        const rect = frame.getBoundingClientRect();
        const cssW = rect.width;
        const cssH = rect.height;

        FRAME_W = cssW;
        FRAME_H = cssH;

        const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));

        cvs.width  = Math.floor(cssW * dpr);
        cvs.height = Math.floor(cssH * dpr);
        cvs.style.width  = cssW + 'px';
        cvs.style.height = cssH + 'px';

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      fitCanvas();

      window.addEventListener('resize', () => {
        cancelAnimationFrame(raf);
        fitCanvas();
        ctx.clearRect(0, 0, FRAME_W, FRAME_H);
        glitching = false;
        titleEl.textContent = ORIGINAL_TEXT;
        titleEl.dataset.text = ORIGINAL_TEXT;
        titleEl.classList.remove('glitching');
      });

      function drawGlitchFrame(tNorm) {
        ctx.clearRect(0, 0, FRAME_W, FRAME_H);

        const intensity = 1 - tNorm;

        const baseAlpha = 0.08 * intensity;
        if (baseAlpha > 0.01) {
          ctx.fillStyle = `rgba(0,0,0,${baseAlpha})`;
          ctx.fillRect(0, 0, FRAME_W, FRAME_H);
        }

        for (let i = 0; i < NOISE_LINES; i++) {
          const y = Math.random() * FRAME_H;
          const h = 1 + Math.random() * 2;
          const alpha = 0.08 + Math.random() * 0.18 * intensity;
          ctx.fillStyle = `rgba(${TERM_R},${TERM_G},${TERM_B},${alpha})`;
          ctx.fillRect(0, y, FRAME_W, h);
        }

        for (let i = 0; i < NOISE_DOTS; i++) {
          const x = Math.random() * FRAME_W;
          const y = Math.random() * FRAME_H;
          const size = Math.random() * 2 + 0.5;
          const gShade = 170 + Math.random() * 85;
          const alpha = 0.12 + Math.random() * 0.25 * intensity;
          ctx.fillStyle = `rgba(${TERM_R},${TERM_G},${gShade},${alpha})`;
          ctx.fillRect(x, y, size, size);
        }

        for (let i = 0; i < SWEEP_LINES; i++) {
          const sweepY = (tNorm + i * 0.33) % 1 * FRAME_H;
          const sweepH = 3 + Math.random() * 2;
          const alpha = 0.22 * intensity;
          ctx.fillStyle = `rgba(${TERM_R},${TERM_G},${TERM_B},${alpha})`;
          ctx.fillRect(0, sweepY, FRAME_W, sweepH);
        }

        const edgeAlpha = 0.18 * intensity;
        if (edgeAlpha > 0.01) {
          const grad = ctx.createRadialGradient(
            FRAME_W / 2, FRAME_H / 2, 0,
            FRAME_W / 2, FRAME_H / 2, Math.max(FRAME_W, FRAME_H)
          );
          grad.addColorStop(0, 'rgba(0,0,0,0)');
          grad.addColorStop(1, `rgba(0,0,0,${edgeAlpha})`);
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, FRAME_W, FRAME_H);
        }
      }

      function loop(now) {
        if (!glitching) {
          ctx.clearRect(0, 0, FRAME_W, FRAME_H);
          return;
        }

        if (!glitchStart) glitchStart = now;
        const elapsed = now - glitchStart;
        const tNorm = Math.min(1, elapsed / GLITCH_DURATION);

        drawGlitchFrame(tNorm);

        if (elapsed >= GLITCH_DURATION) {
          glitching = false;
          ctx.clearRect(0, 0, FRAME_W, FRAME_H);
          glitchStart = 0;

          titleEl.textContent = ORIGINAL_TEXT;
          titleEl.dataset.text = ORIGINAL_TEXT;
          titleEl.classList.remove('glitching');

          return;
        }

        raf = requestAnimationFrame(loop);
      }

      function triggerGlitch() {
        ioClient.emit('control:update', { cmd: 'trigger', t: Date.now() });

        glitching = true;
        glitchStart = 0;

        titleEl.textContent = GLITCH_TEXT;
        titleEl.dataset.text = GLITCH_TEXT;
        titleEl.classList.add('glitching');

        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(loop);
      }

      btn.addEventListener('click', triggerGlitch);
    </script>
  </body>
</html>
